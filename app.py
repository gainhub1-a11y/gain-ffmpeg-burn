# app.py — GAIN: VTT -> ASS (karaoke) + burn-in con FFmpeg
import os
import tempfile
import subprocess
import urllib.request
from fastapi import FastAPI, HTTPException, Query
from fastapi.responses import FileResponse, JSONResponse

app = FastAPI()
FFMPEG_BIN = os.environ.get("FFMPEG_BIN", "ffmpeg")

# ---------------- utils ----------------
def download_to(path: str, url: str):
    try:
        urllib.request.urlretrieve(url, path)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Download failed: {e}")

def escape_for_ffmpeg_path(p: str) -> str:
    # Escapa caratteri critici per il filtro subtitles
    s = p.replace("\\", "\\\\")   # backslash
    s = s.replace("'", "\\'")     # apice singolo
    s = s.replace(":", "\\:")     # due punti (C:\, etc.)
    return s

def clamp(x, a, b): return max(a, min(b, x))
def pad(n): return str(n).zfill(2)

def to_ms(ts: str) -> int:
    # "mm:ss.mmm" o "hh:mm:ss.mmm" -> ms
    a = ts.split(":")
    if len(a) == 2:
        m, s = a; sec, ms = s.split(".")
        return int(m)*60000 + int(sec)*1000 + int(ms)
    h, m, s = a; sec, ms = s.split(".")
    return int(h)*3600000 + int(m)*60000 + int(sec)*1000 + int(ms)

def ms_to_ass(ms: int) -> str:
    cs = (ms // 10) % 100
    s  = (ms // 1000) % 60
    m  = (ms // 60000) % 60
    h  = (ms // 3600000)
    return f"{h}:{pad(m)}:{pad(s)}.{pad(cs)}"

def hex_to_ass(hex_color: str) -> str:
    # "#RRGGBB" -> "&HBBGGRR" (alpha aggiunto a parte nello stile)
    import re
    m = re.match(r"^#?([0-9a-fA-F]{6})$", hex_color or "")
    if not m: return "&H00FFFFFF"
    rr, gg, bb = m.group(1)[0:2], m.group(1)[2:4], m.group(1)[4:6]
    return f"&H00{bb}{gg}{rr}"

def ass_with_alpha(hex_color: str, alpha_pct: int) -> str:
    # 0=opaco … 100=trasparente -> &HAA BB GG RR
    import re
    a = clamp(int(alpha_pct), 0, 100)
    aa = f"{round(255*a/100):02X}"
    m = re.match(r"^#?([0-9a-fA-F]{6})$", hex_color or "") or ["", "000000"]
    rr, gg, bb = m[1][0:2], m[1][2:4], m[1][4:6]
    return f"&H{aa}{bb}{gg}{rr}"

# ------------- VTT -> cues -------------
def parse_vtt(vtt_text: str):
    lines = vtt_text.replace("\r", "").split("\n")
    cues = []
    i = 0
    import re
    while i < len(lines):
        if not lines[i] or re.match(r"^[A-Za-z-]+:", lines[i]):  # header/commenti
            i += 1; continue
        if "-->" not in lines[i]:  # cue id opzionale
            i += 1
        if i >= len(lines): break
        m = re.search(r"(\d+:\d{2}:\d{2}\.\d{3}|\d{1,2}:\d{2}\.\d{3})\s*-->\s*"
                      r"(\d+:\d{2}:\d{2}\.\d{3}|\d{1,2}:\d{2}\.\d{3})", lines[i])
        if not m:
            i += 1; continue
        start, end = to_ms(m.group(1)), to_ms(m.group(2))
        i += 1
        text_lines = []
        while i < len(lines) and lines[i]:
            text_lines.append(lines[i]); i += 1
        text = " ".join(text_lines)
        # rimuovi HTML, normalizza spazi/line-break
        text = re.sub(r"</?[^>]+>", "", text).replace("\\N", " ").replace("\n", " ")
        text = re.sub(r"\s+", " ", text).strip()
        if end > start and text:
            cues.append({"start": start, "end": end, "text": text})
        i += 1  # skip blank
    return cues

def to_ass_dialogue(cue, karaoke_mode: str):
    start = ms_to_ass(cue["start"])
    end   = ms_to_ass(cue["end"])
    text  = cue["text"].replace("\\N", " ").replace("\n", " ")

    if karaoke_mode != "off":
        total_cs = max(1, round((cue["end"] - cue["start"]) / 10))
        words = [w for w in text.split() if w]
        if karaoke_mode == "word" and words:
            import re
            weights = [max(1, len(re.sub(r"[^\w]", "", w))) for w in words]
            s = sum(weights); remaining = total_cs
            parts = []
            for idx, w in enumerate(words):
                d = remaining if idx == len(words)-1 else max(1, round(total_cs*weights[idx]/s))
                remaining -= d
                parts.append(f"{{\\k{d}}}{w}")
            text = " ".join(parts)
        else:
            text = f"{{\\kf{total_cs}}}{text}"

    return f"Dialogue: 0,{start},{end},Default,,0000,0000,0000,,{text}"

def ass_header(font: str, size: int, bold: int, primary: str, secondary: str,
               back: str, align: int, margin_v: int) -> str:
    return (
        "[Script Info]\n"
        "; generated by GAIN\n"
        "PlayResX: 1080\n"
        "PlayResY: 1920\n"
        "ScaledBorderAndShadow: yes\n"
        "WrapStyle: 2\n\n"
        "[V4+ Styles]\n"
        "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n"
        f"Style: Default,{font},{size},{primary},{secondary},&H00000000,{back},{-1 if bold==1 else 0},0,0,0,100,100,0,0,3,0,0,{align},6,6,{margin_v},1"
    )

# -------------- health ---------------
@app.get("/ping")
def ping():
    return {"ok": True}

@app.get("/")
def root():
    return JSONResponse({
        "service": "GAIN ffmpeg burn (VTT->ASS)",
        "endpoints": ["/ping", "/burn"],
        "params_burn": [
            "video_url", "vtt_url",
            "font=Inter", "size=18", "bold=1",
            "primary=#FFFFFF", "secondary=#B3B3B3",
            "back_alpha=70", "align=2", "margin_v=180",
            "karaoke=word|line|off", "crf=18", "preset=veryfast",
            "force_style=<optional>"
        ]
    })

# -------------- main -----------------
@app.get("/burn")
def burn(
    video_url: str = Query(..., description="URL MP4/MOV di input"),
    vtt_url:   str = Query(..., description="URL .vtt sorgente"),

    # stile (default “Instagram friendly”)
    font: str       = Query("Inter"),
    size: int       = Query(18, ge=8, le=64),
    bold: int       = Query(1),  # 1=bold
    primary: str    = Query("#FFFFFF"),
    secondary: str  = Query("#B3B3B3"),
    back_alpha: int = Query(70, ge=0, le=100),
    align: int      = Query(2),   # 2 = bottom center
    margin_v: int   = Query(180),
    karaoke: str    = Query("word"),  # word|line|off

    # encoding
    crf: int        = Query(18, ge=0, le=40),
    preset: str     = Query("veryfast"),
    force_style: str | None = Query(None, description="override stile ASS (opzionale)")
):
    """
    Scarica video + VTT, genera .ASS (karaoke) e fa burn-in tramite libass.
    """
    with tempfile.TemporaryDirectory() as tmpdir:
        in_mp4  = os.path.join(tmpdir, "in.mp4")
        in_ass  = os.path.join(tmpdir, "subs.ass")
        out_mp4 = os.path.join(tmpdir, "out.mp4")
        fontsdir = "/usr/share/fonts/truetype"  # font Noto presenti nell'immagine

        # 1) download input
        download_to(in_mp4, video_url)
        try:
            vtt_text = urllib.request.urlopen(vtt_url).read().decode("utf-8", errors="ignore")
        except Exception as e:
            raise HTTPException(status_code=400, detail=f"Download VTT failed: {e}")

        # 2) VTT -> ASS
        cues = parse_vtt(vtt_text)
        ev = "\n".join(to_ass_dialogue(c, karaoke) for c in cues)

        back = ass_with_alpha("#000000", back_alpha)
        ass = (
            ass_header(font, size, bold, hex_to_ass(primary), hex_to_ass(secondary),
                       back, align, margin_v)
            + "\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n"
            + ev
        )
        with open(in_ass, "w", encoding="utf-8") as f:
            f.write(ass)

        # 3) filtro FFmpeg – CORRETTO: text_shaping=1 (non 'shaping=complex')
        safe_path = escape_for_ffmpeg_path(in_ass)
        vf = f"subtitles='{safe_path}':fontsdir='{fontsdir}':text_shaping=1"
        if force_style and force_style.strip():
            fs = force_style.replace("\\", "\\\\").replace("'", "\\'")
            vf += f":force_style='{fs}'"

        # 4) ffmpeg
        cmd = [
            FFMPEG_BIN, "-y",
            "-i", in_mp4,
            "-vf", vf,
            "-c:v", "libx264",
            "-crf", str(crf),
            "-preset", preset,
            "-pix_fmt", "yuv420p",
            "-c:a", "copy",
            "-movflags", "+faststart",
            out_mp4
        ]

        try:
            subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        except subprocess.CalledProcessError as e:
            err = e.stderr.decode(errors="ignore")[-4000:]
            raise HTTPException(status_code=500, detail=f"FFmpeg error:\n{err}")

        return FileResponse(out_mp4, media_type="video/mp4", filename="gain-burned.mp4")
